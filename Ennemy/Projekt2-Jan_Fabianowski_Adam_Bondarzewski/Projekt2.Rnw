\documentclass{article}

\usepackage{polski}



\usepackage[polish]{babel}
\usepackage{indentfirst}

\usepackage[cp1250]{inputenc}


\usepackage{color}
\usepackage{geometry}
\usepackage[textwidth=18cm,textheight=26cm]{geometry}

\title{Pakiety statystyczne R i SAS - Projekt 2}
\author{Adam Bondarzewski, Jan Fabianowski}


\begin{document}

\section{Opis zawartoœci}
Raport zawiera przyk³ady u¿ycia funkcji graficznych, z naciskiem na u¿ycie pakiety $lattice$. W prezentacji pojawi¹ siê kolejne typy wykresów:

\newline \newline
\begin{tabular}{|c|c|}
\hline
Poziom zadowolenia z ¿ycia & $\textcolor{green}{dotplot}$  \\ \hline
Zarobki wg p³ci & $\textcolor{green}{densityplot}$ \\ \hline
Ogólna analiza danych i ich zale¿noœci & $\textcolor{green}{levelplot}$ \\ \hline
Czas dojazdu do pracy a odleg³oœæ od pracy & $\textcolor{green}{xyplot}$ \\ \hline
\end{tabular}.
\newline \newline

Analizowane dane pochodz¹ z pliku diagnoza osoby
<<>>=
con <- url("http://tofesi.mimuw.edu.pl/~cogito/smarterpoland/Diagnoza2011/diagnozaOsoby2011.RData")
load(con)
@


Analiza danych dzieli siê na dwa etapy. Pierwszy polega na analizowaniu danych w skali ca³ego kraju. Drugi - przeprowadzeniu odpowiedniej analizy, dziel¹c dane ze wzglêdu na granice zaborów z 1815 roku.

Poniewa¿ dok³adne odtworzenie granic rozbiorów na podstawie dostêpnych danych jest niemo¿liwe, staraliœmy siê je odtworzyæ mniej wiêcej, przyporz¹dkowuj¹c poszczególne województwa do jednego z trzech zaborów w nastêpuj¹cy sposób:

\begin{enumerate}
\item do zaboru austriackiego województwa ma³opolskie, podkarpackie,
\item pruskiego - warmiñsko-mazurskie, pomorskie, zachodniopomorskie, lubelskie, wielkopolskie, dolnoœl¹skie, opolskie, œl¹skie, kujawsko-pomorskie,
\item rosyjskiego - lubelskie, podlaskie, mazowieckie, ³ódzkie, œwiêtokrzyskie.
\end{enumerate}

Jako dodatek zamieszczamy na koñcu rêcznie wykonan¹ funkcjê, nak³adaj¹c¹ na mapê Polski dane, przyporz¹dkowuj¹c je poszczególnym województwom. Choæ nie mogliœmy dla niej znaleŸæ miejsca w nowej koncepcji projektu, ¿al by³o nam pozbywaæ siê kilkudziesiêciu minut pracy. Funkcja jest u¿yta do analizy zakresu eksperymentwoania z narkotykami w kraju.



\section{Wczytywanie i obróbka danych}

Dane wczytujemy z zadeklarowanego powy¿ej linku, nastêpnie wybieramy spoœród wszystkich dane nas interesuj¹ce, czyli

\begin{enumerate}
\item województwo,
\item klasa miejscowosci,
<<>>=
levels(diagnozaOsoby2011[,53])
@
\item p³eæ,
\item wiek osoby w 2007 roku,
\item ocena dotychczasowego ¿ycia,
<<>>=
levels(diagnozaOsoby2011[,1161])
@
\item znajomoœæ jêzyka angielskiego,
<<>>=
levels(diagnozaOsoby2011[,1094])
@
\item œrednie zarobki z trzech ostatnich miesiêcy netto,
\item czy osoba pali papierosy,
\item czas dojazdu do pracy,
\item odleg³oœæ od miejsca pracy.
\end{enumerate}

<<results='hide', echo=FALSE>>=


library(lattice)

which(colnames(diagnozaOsoby2011)=="WOJEWODZTWO")
levels(diagnozaOsoby2011[,54])
which(colnames(diagnozaOsoby2011)=="KLASA_MIEJSOWOSCI")
levels(diagnozaOsoby2011[,53])
which(colnames(diagnozaOsoby2011)=="PLEC")
levels(diagnozaOsoby2011[,51])
which(colnames(diagnozaOsoby2011)=="wiek2007") #42
which(colnames(diagnozaOsoby2011)=="dp3") #Ocena dotychczasowego zycia
levels(diagnozaOsoby2011[,1161])
which(colnames(diagnozaOsoby2011)=="dc18") #Znajomosc angielskiego
levels(diagnozaOsoby2011[,1094])
which(colnames(diagnozaOsoby2011)=="dp72") #Zarobki z ostatnich 3 miesiecy netto
which(colnames(diagnozaOsoby2011)=="dp56") #Czy pali papierosy
levels(diagnozaOsoby2011[,1256])
which(colnames(diagnozaOsoby2011)=="dp114") # czas dojazdu do pracy
tail(diagnozaOsoby2011[,1388])
which(colnames(diagnozaOsoby2011)=="dp115") # odleg?osc od miejca pracy
tail(diagnozaOsoby2011[,1389])
@

Nastêpnie dane obcinamy jedynie do niewybrakowanych wierszy

<<>>=
dane=na.omit(diagnozaOsoby2011[,c(54,54,53,51,42,1161,1161,1094,1304,1256,1388,1389)])
dim(dane)


colnames(dane)=c("woj","zabor","kl_miejscowosci","plec","wiek","zadowolenie","zadowolenie_num","ang","zarobki","papierosy","czas_doj_praca","odl_praca")
@

Skutkiem ubocznym takiego podejœcia jest ominiêcie w analizie osób, które nie odpowiedzia³y lub odpowiedzieæ nie mog³y na chocia¿ jedno z tych pytañ. Na przyk³ad do³o¿enie kolumny "Czas dojazdu do pracy" wyeliminowa³o z analizy prawie wszystkie osoby po osiemdziesi¹tym roku ¿ycia, które z kolei odpowiada³y na pozosta³e pytania.

Celem raportu by³o jednak nie sprytne odsiewanie danych, ale zaprezentowanie ró¿nych funkcji graficznych, wiêc pozwoliliœmy sobie na takie uproszczenie.

Kolejnym krokiem by³o do³o¿enie do otrzymanej tabeli dwóch kolumn, odpowiednio
\begin{enumerate}
\item numerycznej oceny dotychczasowego ¿ycia, gdzie odpowiedziom od $OKROPNE$ do $WSPANIALE$ przyporz¹dkowujemy numery odpowiednio od $-3$ do $3$, gdzie odpowiedzi $ANI DOBRE, ANI ZLE$ odpowiada, zgodnie z intuicj¹, cyfra $0$,
\item odpowiedznich zaborów, wg województwa, tak, jak zosta³o to omówione sekcji pierwszej.
\end{enumerate}

<<echo=FALSE,results='hide'>>=
colnames(dane)
levels(dane[,"woj"])
levels(dane[,2])=c("BD/ND/FALA", "Pruski","Pruski","Rosyjski","Pruski","Rosyjski","Austriacki",
                   "Rosyjski","Pruski", "Austriacki","Rosyjski","Pruski","Pruski","Rosyjski",
                   "Pruski","Pruski","Pruski")

dane[,7] = ( 5 - as.numeric(dane[,7]) )
@

W ten sposób otrzymaliœmy ostateczny zbiór danych, z którego bêdziemy odt¹d korzystaæ przy rysowaniu wykresów.

\section{Poziom zadowolenie w zale¿noœci od wieku}

\subsection{Analiza bez podzia³u na zabory}

Najpierw zauwa¿my zasygnalizowany ju¿ wczeœniej problem, czyli przerzedzenie danych o osoby, które nie by³y w stanie odpowiedzieæ na dowolne z pytañ odpowiadaj¹cych kolumnom danych wyjœciowego pliku, które wybraliœmy do danej analizy. G³ównie z powodu dodatnia kolumn $czas dojazdu do pracy$ i $odleg³oœæ od pracy$, iloœæ osób poni¿ej 18 lub powy¿ej 80 roku ¿ycia, które ³api¹ siê do naszej tabeli danych jest tak ma³a, ¿e mo¿na j¹ uznaæ za niereprezentatywn¹.

<<>>=
which(dane[,5]<18) #jest tylko piêæ osób poni¿ej 18 roku ¿ycia
which(dane[,5]>80) #i s¹ tylko cztery osoby powy¿ej osiemdziesi¹tego roku ¿ycia.
@

Osoby dzielimy ze wzglêdy na grupy wiekowe i tworzymy tabelê kontyngencji, celem stowrzenia wykresu $dotplot$

<<>>=
wiek_zadowolenie=table(dane[,7], cut(dane[,5],c(18,25,35,50,60,80),right=F) )
@

Wybór grup wiekowych jest arbitralny. Wyszczególnienie grupy wiekowej $[18,25)$ wynika z czystej ciekawoœci - jest to nasza grupa wiekowa, zaœ do³o¿enie grupy $[50,60)$ mia³ wyszczególniæ osoby przechodz¹ce kryzys wieku œredniego.

Nastêpnie tworzymy wykres

<<>>=
dotplot(wiek_zadowolenie, type = "o",
        auto.key = list(points = TRUE, lines = TRUE, space = "right"),
        main="Poziom zadowolenia a wiek w skali kraju",ylab="Poziom zadowolenia",
        xlab="Iloœæ wyst¹pieñ")
@

Jak widaæ, poziom zadowolenia ma rozk³ad normalny. ¯eby mo¿na by³o dane jeszcze dok³adniej porównywaæ, odt¹d bêdziemy na osi $x$ zaznaczaæ nie czêstoœæ wystêpowania odpowiedzi, ale prawdopodobieñstwo udzielenia odpowiedzi w zale¿noœci od grupy wiekowej.

Tworzymy w tym celu specjalna funkcjê $wiek_zadowoleniePROB$, która przyda siê przy tworzeniu analogicznych wykresów dla poszczególnych zaborów.

<<result='hide'>>=
wiek_zadowoleniePROB = function(x) {
  y = x
  for (i in 1:length(x[1,])) {
    y[,i] = x[,i]/sum(x[,i])
  }
  wiek_zadowoleniePROB = y
}
@

Obiecany wykres generuje siê w nastêpuj¹cy sposób

<<>>=
dotplot(wiek_zadowoleniePROB(wiek_zadowolenie), type = "o",
        auto.key = list(points = FALSE, lines = TRUE, space = "right"),
        main="Poziom zadowolenia a wiek dla wszystkich wojewodztw",xlab="Prawdopodobienstwo",
        ylab="Zadowolenie")

remove(wiek_zadowolenie)
@

Teraz wyraŸnie widaæ, ¿e najszêœliwsi s¹ ludzie w wieku $25-35$ lat, potem z wiekiem zadowolenie powoli maleje. Nie ma spodziewanego spadku zadowolenia w grupie wiekowej $50-60$.


\subsection{Analiza z podzia³em na zabory}

Przeprowadzamy teraz analogiczn¹ analizê dla poszczególnych zaborów.

Dziêki u¿yciu stworzonej wczeœniej funkcji $wiek_zadowoleniePROB$, mo¿emy szybko wygenerowaæ wykresy, po uprzednim storzeniu odpowiednich tabel kontyngencji.

\begin{enumerate}
\item Zaboru pruski.
<<>>=
wiek_zadowoleniePruski=table( dane[dane[,2]=="Pruski",7],
cut(dane[dane[,2]=="Pruski",5],c(18,25,35,50,60,80),right=F) )

plot_Pruski=dotplot(wiek_zadowoleniePROB(wiek_zadowoleniePruski),
                    type = "o",

        main="Pruski",
                    xlab="Prawdopodobieñstwo",
        ylab="Zadowolenie")

remove(wiek_zadowoleniePruski)
@

\item Zaboru Austriackiego
<<>>=
wiek_zadowolenieAustriacki=table( dane[dane[,2]=="Austriacki",7],
cut(dane[dane[,2]=="Austriacki",5],
                                      c(18,25,35,50,60,80),right=F) )

plot_Austriacki=dotplot(wiek_zadowoleniePROB(wiek_zadowolenieAustriacki),
                        type = "o",

        main="Austriacki",
                        xlab="Prawdopodobieñstwo",
        ylab="Zadowolenie")

remove(wiek_zadowolenieAustriacki)
@

\item Zabor Rosyjskiego
<<>>=
wiek_zadowolenieRosyjski=
  table( dane[dane[,2]=="Rosyjski",7],
                        cut(dane[dane[,2]=="Rosyjski",5],
                         c(18,25,35,50,60,80),right=F) )

plot_Rosyjski=dotplot(wiek_zadowoleniePROB(wiek_zadowolenieRosyjski),
        type = "o",
        auto.key = list(points = TRUE, lines = TRUE, space = "right"),
        main="Rosyjski",
                      xlab="Prawdopodobieñstwo",
        ylab="Zadowolenie")

remove(wiek_zadowolenieRosyjski)
@

\end{enumerate}

I rysujemy stworzone powy¿ej wykresy.

<<>>=
plot(plot_Pruski, split=c(1,1,2,1))
plot(plot_Austriacki, split=c(2,1,2,1), newpage=FALSE)

plot(plot_Rosyjski, newpage=T)
@

Poziom zadowolenia najbardziej wyrównany jest w zaborze Pruskim. Zadowolenie najbardziej z wiekiem spada w zaborze Austriackim - po $35$ roku ¿ycia nastêpuje ogromy spade, a potem dwa kolejne, równie du¿e.

Najciekawsze wyniki s¹ z terenów by³ego zaboru Rosyjskiego, gdzie zadowolenie spada doœæ umiarkowanie, a po 60 roku ¿ycia nastêpuje gwa³towny spadek, zapewne zwi¹zany z koñcem aktywnoœci zawodowej.

\section{Wynagrodzenie kobiet i mê¿czyzn}

\subsection{Analiza bez podzia³u na zabory}

Zauwa¿my najpierw, ¿e ponad $94$ procent osób z tabeli zarabia poni¿ej $5000$ z³otych miesiêcznie.

<<>>=
sum(dane[,9]<5000)/length(dane[,9])
@

Je¿eli wygenerujemy wykresy jedynie dla ludzi zarabiaj¹cych nie wiêcej ni¿ $5000$ z³otych, nie stracimy wiele ogólnoœci, a wykresy zyskaj¹ znacznie na czytelnoœci.

$densityplot$ dla tak okrojonych danych w skali kraju to

<<>>=
densityplot(~ dane[dane[,9]<5000,9], data=dane,
            plot.points = F,
            groups = dane[,4][drop=T],
            auto.key = TRUE,xlab="Zarobki",ylab="Gêstoœæ",
            main="Zarobki wg p³ci w skali kraju")
@

Zarobki kobiet i mê¿czyzn sa zadziwiajaco podobne. Warto zwróciæ uwagê na dwie rzeczy.

\begin{enumerate}
\item W okolicy $1000$ z³otych nastêpuje ogromny skok gêstoœci. Doœæ pesymistyczna hipoteza, ¿e jest to miejsce wyznaczaj¹ce p³acê minimaln¹, okazuje siê nieprawdziwa - w 2007 p³aca minimalna wynosi³a nieca³e $700$ z³otych. Jest to pewnie spowodowane tym, ¿e $1000$ z³otych by³o barier¹ psychiczn¹ i ma³o kto chcia³ pracowaæ za ni¿sz¹ stawkê.
\item Pensjê poni¿ej $1400$ otrzymuje wiêcej kobiet ni¿ mê¿czyzn, zaœ powy¿ej - wiêcej mê¿czyzn. Generalnie wiêc prad¹ jest, ¿e kobiety zarabiaj¹ gorzej, choæ widoczne tu ró¿nice s¹ du¿o mniej dramatyczne, ni¿ mog³oby siê wydawaæ.
\end{enumerate}

\subsection{Analiza z podzia³em na zabory}

Pakiet $lattice$ pozwala ³atwo wygenerowaæ po¿¹dany wykres:

<<>>=
densityplot(~ dane[dane[,9]<5000,9] | dane[,2], data=dane,
            plot.points = F,
            groups = dane[,4][drop=T],
            auto.key = TRUE,xlab="Zarobki",ylab="Gêstoœæ",main="Zarobki wg p³ci")
@

Zarobki na wszystkich terenach maj¹ dosyæ podobn¹ strukturê, w terenach by³ego zaboru austriackiego s¹ zdecydowanie ni¿sze, ni¿ gdzie indziej. Tereny by³ego zaboru pruskiego to dzisiejsza zachodnia Polska, wiêc spodziewaliœmy siê wiêkszej ró¿nicy wynagrodzeñ miêdzy zaborem Pruskim a Rosyjskim. Je¿eli jednak z zaboru Rosyjskiego wyrzucimy Warszawê (co osi¹gn¹æ mo¿emy tylko w przybli¿onym stopniu, wyrzucaj¹c wszystkie osoby z województwa Mazowieckiego, które mieszkaj¹ w miastach o liczbie mieszkañców powy¿ej 500 tysiêcy ludzi),

<<>>=
densityplot(~ dane[1==((dane[,9]<5000)-((dane[,1]=="Mazowieckie ") +
                                (dane[,3]=="miasta o liczbie mieszkancow 500 tys. i wiecej"))),9]
            | dane[,2], data=dane,
            plot.points = F,
            groups = dane[,4][drop=T],
            auto.key = TRUE,xlab="Zarobki",ylab="Gêstoœæ",
            main="Zarobki wg p³ci")
@

Teraz zgodnie z oczekiwaniami zajwy¿sze zarobki s¹ z zaborze Pruskim. SprawdŸmy jeszcze te wnioski rysuj¹c wykresy dla zaborów niezaleŸnie od p³ci.

<<>>=
densityplot(~ dane[dane[,9]<5000,9], data=dane,
            plot.points = F,
            groups = dane[,2][drop=T],
            auto.key = TRUE,xlab="Zarobki",ylab="Gêstoœæ",
            main="Zarobki wg zaboru")

@

I znowu bez Warszawy:

<<>>=
densityplot(~ dane[1==((dane[,9]<5000)-(dane[,1]=="Mazowieckie ")),9],
            data=dane,
            plot.points = F,
            groups = dane[,2][drop=T],
            auto.key = TRUE,xlab="Zarobki",ylab="Gêstoœæ",
            main="Zarobki wg zaboru")

@

Co potwierdza poczynione wczeœniej spostrze¿enia.

\section{Analiza danych ciag³ych za pomoc¹ macierzy korelacji}

\subsection{Analiza bez podzia³u na zabory}

SprawdŸmy teraz korelacjê poszczególnych danych.

<<>>=
cor.dane <- cor(dane[, !sapply(dane, is.factor)],
                use = "pair")
levelplot(cor.dane, main="Macierz korelacji",
          scales = list(dane= list(rot = 90)),xlab="",ylab="")
@

Jak mo¿na by³o oczekiwaæ, oleg³oœæ od pracy i czas dojazdu do pracy s¹ silnie dodatnio skorelowane. Okazuje siê równie¿, ¿e d³u¿szy czas dojazdu do pracy oznacza niekiedy ni¿sze zarobki (mamy ujemn¹ korelacjê).

Zaskakuj¹ce mo¿e siê wydawaæ, ¿e zarobki i zadowolenie nie s¹ skorelowane.

\subsection{Analiza z podzia³em na zabory}

Rozbijamy znowu dane na regiony.

<<>>=
dane_Pruski=subset(dane,dane[,2]=="Pruski")
dane_Rosyjski=subset(dane,dane[,2]=="Rosyjski")
dane_Austriacki=subset(dane,dane[,2]=="Austriacki")

cor.dane_Austriacki=cor(dane_Austriacki[, !sapply(dane, is.factor)],
                        use = "pair")
cor.dane_Rosyjski=cor(dane_Rosyjski[, !sapply(dane, is.factor)],
                      use = "pair")
cor.dane_Pruski=cor(dane_Pruski[, !sapply(dane, is.factor)],
                       use = "pair")

wykres1=levelplot(cor.dane_Pruski,scales=list(x=list(rot=90)),main="Pruski",xlab="",ylab="")
wykres2=levelplot(cor.dane_Austriacki,scales=list(x=list(rot=90)),main="Austriacki",
                  xlab="",ylab="")
wykres3=levelplot(cor.dane_Rosyjski,scales=list(x=list(rot=90)),main="Rosyjski",xlab="",ylab="")

plot(wykres1, split=c(1,1,2,2),newpage=FALSE)
plot(wykres2, split=c(2,1,2,2),newpage=FALSE)
plot(wykres3, split=c(1,2,2,2), newpage=FALSE)
@

\section{Macierz korelacji dla wiêkszej iloœci zmiennych}

Rozszerzmy teraz nasz zbiór danych o nowe kolumny, które intuicyjnie powinny byæ silnie skorelowane:

\begin{enumerate}
\item przepracowane w tygodniu godziny,
\item godziny spêdzone przed komputerem,
\item godziny poœwi¹cone przegl¹daniu internetu.
\end{enumerate}

<<echo=FALSE, results='hide'>>=
which(colnames(diagnozaOsoby2011)=="dd4")
which(colnames(diagnozaOsoby2011)=="dp129")
which(colnames(diagnozaOsoby2011)=="dp134")

dane_rozsz=na.omit(
diagnozaOsoby2011[,c(54,54,53,51,42,1161,1161,1094,1304,1256,1388,1389,1115,1431,1453)])
dane_rozsz[,7] = ( 5 - as.numeric(dane_rozsz[,7]) )

colnames(dane_rozsz)=c("woj","zabor","kl_miejscowosci","plec","wiek",
                       "zadowolenie","zadowolenie_num",
"ang","zarobki","papierosy","czas_doj_praca","odl_praca",
                 "godz_pracy","godz_komp","godz_internet")

levels(dane_rozsz$kl_miejscowosci)=c("BD/ND/FALA","miasta > 500 tys.","miasta 200-500 tys.","miasta 100-200 tys.","miasta 20-100 tys.","miasta < 20 tys.","wieœ")

# Usuwamy z kolumny zarobki wielkosci 99999, ktore w ankiecie by³y sposobem kodowania "odmawiam
# odpowiedzi na pytanie".

attach(dane_rozsz)
zarobki=zarobki[zarobki<99999]

# Skonwertujmy czas - z minut na godziny.

czas_doj_praca =czas_doj_praca/60
detach(dane_rozsz)
@

Nowy wykres to

<<>>=
cor.dane_rozsz <- cor(dane_rozsz[, !sapply(dane_rozsz, is.factor)],
                      use = "pair")
levelplot(cor.dane_rozsz, scales=list(x=list(rot=90)),main="Macierz korelacji",
          xlab="",ylab="")
@

Czas spêdzony przy komputerze jest dodatnio skorelowany z iloœci¹ godzin przeznaczonych na korzystanie z internetu, co wskazuje, ¿e w Polsce rzadko u¿ywa siê komputerów, które nie s¹ pod³¹czone do sieci.

Widac te¿, ze wiek jest s³abo ujemnie skorelowany z iloœci¹ godzin spêdzona na przegl¹daniu internetu, podobnie korelacja miêdzy wiekiem a czasem korzystania z komputera jest ujemna. Jednak druga jest co do modu³u mniejsza od pierwszej, sk¹d wniosek, ¿e im ktoœ starszy, tym mniej korzysta z komputera do przegl¹dania internetu.

\section{Analiza zale¿noœci czasu dojazdu do pracy od odleg³oœci}

\subsection{W skali kraju}

Jak zauwa¿yliœmy w poprzednim rozdziale, korelacja miêdzy czasem dojazdu do pracy a odleg³oœci¹ wynosi jedynie $0.6$, co mo¿e siê wydawaæ niezgodne z intuicj¹. Zbadajmy wiêc tê zale¿noœæ dok³adniej.

Rysujemy na pocz¹tku zwyk³y $xyplot$,

<<>>=
xyplot(czas_doj_praca~odl_praca, data=dane_rozsz, type="p", xlab="Odleg³oœæ od pracy",
       ylab="Czas dojazdu do pracy",main="Zale¿noœæ")
@

który okazuje siê ma³o czytelny. Dok³adamy do niego wiêc jeszcze krzyw¹ regresji.

<<>>=
xyplot(czas_doj_praca~odl_praca, data=dane_rozsz, type=c("p","r"),xlab="Odleg³oœæ od pracy",
       ylab="Czas dojazdu do pracy",main="Zale¿noœæ z krzyw¹ regresji")
@

Widaæ, ¿e zale¿noœæ jest w przybli¿eniu liniowa, ze stosunkowo du¿¹ wariancj¹.

\subsection{Ze wzglêdu na klasê miejscowoœci}

Powtórzmy analizê przy rozbiciu wzgledem wielkosci miejscowoœci.

<<>>=
xyplot(czas_doj_praca~odl_praca | kl_miejscowosci,
       data=dane_rozsz,type=c("p","r"),col="grey20",pch=16,xlab="Odleg³oœæ od pracy",
       ylab="Czas dojazdu do pracy")
@

Ze wzrostem liczby mieszkañców miejscowoœci maleje œrednia odleg³oœæ od miejsca pracy, co jest zwi¹zane z tym, ¿e osoby mieszkaj¹ce na wsi lub w ma³ych miejscowoœciach czêsto doje¿d¿aj¹ do pracy). Przyk³adowo w miastach powy¿ej $500 tys.$ mieszkañców nie ma przypadku, by ktoœ doje¿d¿a³ wiêcej ni¿ $100 km$, zaœ zdecydowana wiêkszoœæ ludzi mieszka nie wiêcej ni¿ $50 km$ od miejsca pracy.

Na wszystkich wykresach widaæ, ze zale¿noœæ czasu dojazdu do pracy od odleg³oœæi jest w dalszym ci¹gu liniowa. W przypadku najwiêkszych miast nachylenie krzywej jest wiêksze, co mo¿e byæ zwi¹zane z wiêkszym zat³oczeniem, powoduj¹cym d³u¿szy czas dojazdu, nawet w przypadku ma³ych odleg³oœci.

\subsection{Analiza zale¿noœci czasu dojazdu od odleg³osci przy rozbiciu na zabory}

Teraz przeprowadzimy tê analizê dla poszczególnych zaborów, przy czym w celu ograniczenia liczby komórek, scalamy $levels$ klasy miejscowoœci do
\begin{enumerate}
\item miast powy¿ej $200 tys.$ mieszkañców,
\item miasta poni¿ej $200 tys.$ mieszkañców,
\item wsie.
\end{enumerate}

<<echo=FALSE,results='hide'>>=
dane[,13]=dane[,3]
colnames(dane)
colnames(dane)=c(colnames(dane)[-13],"kl_miejscowosci2")
colnames(dane) #sprawdzenie

levels(dane[,"kl_miejscowosci2"])
levels(dane[,"kl_miejscowosci2"])=c("BD/ND/FALA","Miasta > 200 tys.",
                                    "Miasta > 200 tys.","Miasta < 200 tys.",
                                    "Miasta < 200 tys.","Miasta < 200 tys.","Wsie")
@

<<>>=
xyplot(czas_doj_praca~odl_praca | kl_miejscowosci2+zabor,
       data=dane, type=c("p","r"),col="grey20",pch=16,xlab="Odleg³oœæ od pracy",
       ylab="Czas dojazdu do pracy")
@

W przypadku najwiêkszych miast zaboru pruskiego krzywa regresji ma mniejsze nachylenie ni¿ dla pozosta³ych zaborów. Sugeruje to, ¿e w miastach by³ego zaboru pruskiego (czyli na przyk³ad we Wroc³awiu, Bydgoszczy, Toruniu, Gdañsku, Katowicach, Poznaniu i Szczecinie) lepiej zosta³y rozwi¹zane problemy logistyczne, powstawa³y lepsze plany miast, b¹dŸ te¿ w tych miastach jest po prostu lepszy system komunikacji miejskiej.

\section{Dodatek - narkotyki w poszczególnych województwach}

Zaprezentujemy teraz funckjê, która rysuje dane na mapie Polski, przyporz¹dkowuj¹c wyniki poszczególnych województw w okolicy odpowiedniego miasta wojewódzkiego.

Najpierw wczytamy mapê Polski (z pakietu $maps$) i wczytamy z internetu wspó³rzêdne geograficzne województw.

<<echo=FALSE, results='hide'>>=
# install.packages("maps")
library("maps")
p.map<-map("world", "Poland", plot=F, fill =F)

#Ramka - nazwy wojewodztw i wspolrzedne stolic poszczegolnych wojewodztw
woj=c(levels(diagnozaOsoby2011$WOJEWODZTWO)[2:17])
szer=c(51.110,53.120,52.740,51.240,51.770,50.060,
             52.259,50.679,50.049,53.139,54.360,50.259,
             50.889,53.779,52.399,53.430)
dl=c(17.030,18.010,15.230,22.570,19.459,19.959,
             21.020,17.940,21.999,23.159,18.639,19.020,
             20.649,20.489,16.900,14.529)
ramka=cbind(woj,dl,szer)
wsp=ramka
@

Funkcj¹ rysuj¹c¹ mapê z zaznaczonymi na niej miastami wojewódzkimi jest

<<>>=
plotwojewodztwa = function() {
  plot(p.map, type="l",main="Miasta wojewodzkie",xlab="E",ylab="N")
  for (i in 1:length(wsp[,1])) points(wsp[,3],wsp[,2],pch=15)
}
@


<<results='hide',echo=FALSE>>=
levels(diagnozaOsoby2011$bp73) # - probowalem narkotykow
levels(diagnozaOsoby2011$WOJEWODZTWO)

which(colnames(diagnozaOsoby2011)=="bp73")
which(colnames(diagnozaOsoby2011)=="WOJEWODZTWO")
wojewodztwa_proboja = na.omit(diagnozaOsoby2011[,c(54,527)])

nieproboja = tapply(wojewodztwa_proboja[,2]=="NIE",
                    wojewodztwa_proboja[,1],sum)
takproboja = tapply(wojewodztwa_proboja[,2]=="TAK",
                    wojewodztwa_proboja[,1],sum)

nieproboja=nieproboja[-1]
takproboja=takproboja[-1]
@

Teraz mo¿emy nanieœæ dane na mapkê, u¿ywaj¹c funkcji $jitter$.

<<>>=
plotwojewodztwa()
for (i in 1:length(takproboja)) {
  replicate(round(nieproboja[i]/5),points(jitter(as.numeric(wsp[i,2]),1.8),
                                          jitter(as.numeric(wsp[i,3]),0.5),
                                          col="green",pch=4))
  replicate(round(takproboja[i]/5),points(jitter(as.numeric(wsp[i,2]),1.8),
                                          jitter(as.numeric(wsp[i,3]),0.5),
                                          col="red",pch=1))
}
@

Zamiast u¿ywaæ funkcji jitter mo¿emy u¿yæ losowania z dwuwymiarowego rozk³adu normalnego, co daje lepszy efekt wizualny. 

<<>>=
plotwojewodztwa()
for (i in 1:length(takproboja)) {
  replicate(round(nieproboja[i]/5),points(rnorm(1,as.numeric(wsp[i,2]),0.5),rnorm(1,as.numeric(wsp[i,3]),0.45),col="green",pch=4))
  replicate(round(takproboja[i]/5),points(rnorm(1,as.numeric(wsp[i,2]),0.5),rnorm(1,as.numeric(wsp[i,3]),0.45),col="red",pch=1))
}
@

\end{document}